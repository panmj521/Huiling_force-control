这是关于文件中的代码以及注释的文件说明

"""
1.Huiling_scara:
 该文件类的初始化应该要做三件事情，第一机械臂的初始化 第二z轴电机的初始化 第三末端关节的初始化(后续需要再加上)
 机械臂的初始化按正常流程走应该没什么问题，还需要注意的就是调节碰撞检测的灵敏度set_robot_joint_torque_value，
 如果后续末端机械臂换成刚性结构，相应的灵敏度也应该要调整，避免运动的时候就出现碰撞检测。

 线程的管理不需要更改，线程中的逻辑是每隔了一段时间就会检查一下机械臂状态，出现问题就停机报警。

 末端TCP的位置获取这一块有些需要注意。首先Z轴电机位置的获取，由于Z轴电机在读取位置的时候会出现负数，大概情况是
 读取从-12354到一个很大的数，但是测试了发现负数的时候就已经在最低点，所以我将获取的负数位置直接置零了。同时Z轴的位置
 如果小于0.01后，则考虑精度问题，也直接置零。
 在位姿的获得，可以发现做了一个转变，就是从基座坐标系转换到工具坐标系(力传感器坐标系),相当绕x轴旋转了180°之后，再
 根据r的偏转，来确定绕z轴的偏转。 这个位姿参数对后续的力控算法至关重要，如果不对的话整个流程测试都会有问题
 get_arm_position（）官方确定每次更新频率最大为50ms也就是20hz，但我实际上用了100hz，因为实际测试我发现20hz
 还是100hz都会出现在读取状态数据更新的时候，偶尔有几次数据出现不准确的情况，也就是关节角读取和上一次差别太大的问题
 所以这个问题就有点无解，特别是在做逆运动学那块会导致出现一个比较大的问题

 逆运动学的问题我写在了代码注释中。

 _move_z_axis_p（）是关于z轴的移动，z轴方向移动响应非常快，所以它的控制频率可以非常之高
 关键是机械臂的移动，move_joint模式1的响应如果角度较大，细分较多的话最多会阻塞30ms，阻塞不多的情况下应该为10ms以内。
 我把机械臂的控制函数问题也写在了代码注释中。

 send_command的注释以及问题我也写在了代码中了。
"""
